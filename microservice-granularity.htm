微服务架构
从应用架构角度，我们认为微服务架构是实现云原生应用的最佳架构实践。微服务架构本质是一种软件组件化方式，围绕这一本质，我们对与之紧密相关的微服务的粒度、划分原则问题展开讨论。

1.微服务架构的定义
我们先来阐述我们对微服务架构的理解，它是我们如何看待微服务粒度、如何确定微服务划分原则的基础。我们对微服务架构做如下定义：

微服务架构是一种从业务角度，对应用进行功能切分，并以分布式运行的组件化方式。微服务架构切分后的组件应满足以下要求：各组件具备单一但完整的业务功能，可以独立运行、独立升级；各组件具备定义良好的轻量接口；组件运行力求自给自足，自己管理自己的数据。尽量减少组件间的依赖和影响，只在必要时才通过接口调用其它组件。

通过以上的功能切分，形成多个可分散治理、功能完备、耦合度低、拥有独立生命周期、可灵活拼装的业务单元，各个独立的单元就是微服务。

2.微服务的粒度
微服务粒度太小会带来效率和可用性降低问题，而过大又会导致灵活性降低。那么微服务合适的粒度是什么？微服务的“微”并不是限定微服务的大小尺寸，而是限定微服务所包含的业务功能。我们对微服务架构定义要求切分的组件需要“具备单一但完整的业务功能”，所以“微”是指业务功能单一、但完整。

（1）什么是功能单一且完整。从业务角度看，“单一”且“完整”功能的微服务具备以下特点。

“单一”：业务功能原子性，执行过程不可出错或中断，否则已执行部分的状态就应该回滚或重做。如果服务中某部分执行得到的结果，与其它部分执行出错与否没有关系，那么这样粒度的微服务的业务功能就不是“单一”的，这一部分的逻辑应该拆分出来成为一个新的微服务。以此类推继续拆分，直到违反“完整”原则为止。由此可见，“单一”原则用来限定微服务粒度的上限

“完整”：如果继续细分，得出的更小粒度服务将失去业务意义。如果说合适粒度的微服务完成一个业务“任务”，继续细分只能得到一系列完成这项“任务”所需的“步骤”。单从“步骤”上看，我们无法判断这个“步骤”是在完成哪个“任务”。显然，划分到“步骤”这个级别，对于微服务粒度来说就太细了。由此可见，“完整”原则用来衡量微服务粒度的下限

（2）示例。举一个银行发行信用卡的例子来说明“单一但完整”的含义。银行为客户发放信用卡通常包括几个主要环节：受理、复核、获取征信、额度审批、授信、开户。

假设柜员已经完成了受理环节，而此时复核员不能及时进行复核工作，已经完成的受理工作仍然是有效的，客户可以离开后等待结果；等复核员忙完其它工作，确认刚受理的开户申请信息完整有效，接下来需要从人民银行获取此客户个人征信信息，很不巧系统因故障暂时无法访问人民银行征信系统，那么可以等故障恢复后再查询即可，前面已经完成的受理和复核工作仍然有效，不需要回滚或者重做。所以我们认为如果把受理、复核、获取征信等放在一个服务中实现，这个服务就不符合业务功能“单一”原则，它们可以被分开，各自被不同的服务实现。

那么“受理”这个业务功能，它需要继续拆分吗？假设我们继续细分“受理”功能，可能会包括：信息录入、证件扫描、提交请求等。我们发现单独看每个细分项，都无法判断其业务意义，它们是必须组合在一起的“步骤”，才能完成“受理”这个功能，这样才满足“完整”原则的要求。同时，我们发现这些“步骤”组合在一起具备原子性，例如提交请求失败，可能是因为信息录入或证件扫描信息不全、不符合规范等，必须重新检视信息录入和证件扫描这两个步骤，确保没有问题，再次进行提交请求的尝试。

所以，在信用卡发行这个场景中，“受理”这个环节就是一个可以考虑的、合适粒度的微服务。

（3）和尺寸大小无关。我们不应该把“代码行数多而不好维护”当成决定微服务粒度的因素。软件的可维护性是由软件实现的设计方法、模块化、编码水平等决定的，微服务的可维护性和微服务尺寸大小没有直接关系。选择微服务的粒度不应该看代码行数多少，而是要考虑把多少相关的逻辑放入一个微服务的边界内来实现。

微服务的粒度就是微服务所包含的逻辑边界，它只取决于微服务的切分原则。

3.微服务的切分原则
微服务切分没有普适的标准，需要综合考虑多个因素。以下总结我们在项目中的经验，供读者参考。

(1)业务视角。服务可以分为业务服务和技术服务。根据我们对微服务架构的定义，微服务的切分应该从业务角度进行功能划分，每个微服务应该都提供的是业务服务。

例如，用微服务架构来实现在线购物系统，微服务划分的结果可能会出现类似账户管理、订单管理、商品目录管理等，它们每一个都完成完整的业务功能，可以独立运行、升级替换而不互相影响。从微服务内部的实现上看，它们每个都可能包括Web前台展现、后台业务逻辑、数据库持久化访问等技术部分。

(2)自给自足。我们常见到有项目把共用的技术处理逻辑从各微服务中提取出来，以一个独立的、提供“技术服务”的组件运行，并提供RESTful接口被其它微服务调用，例如“数据库访问服务”、“日志记录服务”等。出现这种切分方式的原因是人们沿袭了传统的组件化观念和习惯，目的是有利于代码复用，减少重复维护工作等。

但微服务切分的目的不是为了复用，而是为了提高架构的灵活性。微服务架构要求每个微服务自己包含所需的技术处理逻辑，包括数据存取、加工、发送接收等，由此来保障微服务运行自给自足，尽量避免微服务对外界的依赖。这对保证微服务的独立运行、独立升级、灵活拼装能力等是非常重要的。

从我们对微服务架构的定义角度看，上面的 “技术服务”组件，违反了从“业务视角”进行服务划分的原则；同时，这一做法也不符合 “组件运行力求自给自足，自己管理自己的数据。尽量减少组件间的依赖和影响”的要求，因此我们不建议这样的切分方式用于微服务架构。

为了提高代码的复用性，我们可以考虑把共用的技术处理逻辑封装成单独的公用库，在微服务代码中静态引用就可以了。这样在提高代码复用性的同时，仍然保证了微服务的独立性。

(3)功能单一但完整。按照“单一但完整”的定义，只要是实现单一业务功能需要的逻辑，我们都应该放在这个微服务组件中，而不是放在另一个微服务中被调用，否则就违反了“完整”原则；反过来说，只要是和实现某单一业务功能无关的逻辑，我们一定要把它拿出来，放在它应该属于的那个微服务中去，否则那个微服务就将违反“完整”原则。

 (4)非事务性和最终一致性。微服务架构中如果需要跨多个微服务维护事务则在本质上是处理分布式系统的事务性和数据一致性问题，这往往带来高昂的成本，相比之下，只在一个微服务内维持事务性要容易得多。

因此，在决定微服务拆分的边界时，应当考虑把有事务性要求、数据强一致性要求的逻辑放在一个服务中。微服务拆分后，微服务的边界应该符合非事务性、数据最终一致性即可的要求。

(5)平衡效率。微服务切分后形成的各个服务以分布式方式运行，因此相对于传统单体应用，微服务架构在可靠性和效率方面都有下降。一个完整的业务需要的微服务越多，它的可靠性和效率就越低。

因此，微服务拆分应该同时关照业务的可靠性和效率，必要时可以考虑把相关微服务进行合并，这实质上是在效率、可靠性和微服务的“功能单一”原则之间做权衡。

回顾
微服务架构是一种能极大提高业务架构灵活性的组件化、分布式运行理念，它是云原生应用的最佳架构实践。
